#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <GL/glut.h>  // Añadir GLUT para dibujar texto
#include <cmath>
#include <string>
#include <vector>
#include <iostream>

// Estructura para almacenar puntos 3D
struct Point {
    float x, y, z;
};

// Vector para almacenar los puntos que el usuario ingresará
std::vector<Point> userPoints;

// Función para dibujar texto en las coordenadas 3D
void drawText(const char* text, float x, float y, float z) {
    glRasterPos3f(x, y, z);  // Posición donde queremos colocar el texto
    for (const char* c = text; *c != '\0'; c++) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);  // Usar fuente bitmap
    }
}

// Configuración del viewport y la cámara
void setupViewport(GLFWwindow* window) {
    int width, height;
    glfwGetFramebufferSize(window, &width, &height);
    glViewport(0, 0, width, height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-100.0, 100.0, -100.0, 100.0);  // Proyección ortográfica 2D
}

// Función para dibujar los ejes de coordenadas X e Y con marcas numéricas de 2 en 2
void drawAxes() {
    glBegin(GL_LINES);

    // Eje X - Rojo
    glColor3f(1.0f, 0.0f, 0.0f);  // Rojo para el eje X
    glVertex3f(-100.0f, 0.0f, 0.0f);
    glVertex3f(100.0f, 0.0f, 0.0f);

    // Eje Y - Verde
    glColor3f(0.0f, 1.0f, 0.0f);  // Verde para el eje Y
    glVertex3f(0.0f, -100.0f, 0.0f);
    glVertex3f(0.0f, 100.0f, 0.0f);

    glEnd();

    // Dibujar marcas y valores en los ejes de 2 en 2
    for (int i = -10; i <= 10; i += 2) {  // Incremento de 2 en 2
        std::string label = std::to_string(i * 2);

        // Marcas y valores en el eje X
        glColor3f(0.0f, 0.0f, 0.0f);
        drawText(label.c_str(), i * 10, -1.0f, 0.0f);  // Texto ligeramente debajo del eje X

        // Marcas y valores en el eje Y
        drawText(label.c_str(), -2.0f, i * 10, 0.0f);  // Texto ligeramente a la izquierda del eje Y
    }
}

// Función para graficar la curva y = x^2 en 2D
void renderQuadraticCurve() {
    glColor3f(0.0f, 0.5f, 1.0f);  // Curva en color azul claro
    glBegin(GL_LINE_STRIP);  // Dibujar una curva con líneas conectadas
    for (float x = -10.0f; x <= 10.0f; x += 0.1f) {
        float y = x * x;  // y = x^2
        glVertex3f(x * 10, y * 10, 0.0f);  // Ampliando la escala de la curva
    }
    glEnd();
}

// Función para graficar la curva y = sin(x)
void renderSineCurve() {
    glColor3f(1.0f, 0.5f, 0.0f);  // Curva seno en color naranja
    glBegin(GL_LINE_STRIP);
    for (float x = -10.0f; x <= 10.0f; x += 0.1f) {
        float y = sin(x);  // y = sin(x)
        glVertex3f(x * 10, y * 10, 0.0f);  // Escalar la curva seno para que sea visible
    }
    glEnd();
}

// Función para graficar los puntos dados por el usuario
void renderUserPoints() {
    glColor3f(1.0f, 0.0f, 0.0f);  // Puntos en color rojo
    glPointSize(5.0f);  // Tamaño de los puntos
    glBegin(GL_POINTS);
    for (const auto& point : userPoints) {
        glVertex3f(point.x, point.y, 0.0f);  // Mantener en el plano XY
    }
    glEnd();
}

// Función para calcular y graficar la distancia entre dos puntos
void renderDistanceBetweenPoints(const Point& p1, const Point& p2) {
    // Dibujar una línea entre los dos puntos
    glColor3f(0.0f, 0.0f, 1.0f);  // Línea en color azul
    glBegin(GL_LINES);
    glVertex3f(p1.x, p1.y, 0.0f);
    glVertex3f(p2.x, p2.y, 0.0f);
    glEnd();

    // Calcular la distancia Euclidiana en 2D
    float distance = sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));

    // Mostrar la distancia en el punto medio entre los dos puntos
    std::string distanceText = "Distancia: " + std::to_string(distance);
    drawText(distanceText.c_str(), (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, 0.0f);
}

int main() {
    // Solicitar puntos al usuario
    int numPoints;
    std::cout << "¿Cuántos puntos quieres graficar (al menos 2)?: ";
    std::cin >> numPoints;

    if (numPoints < 2) {
        std::cout << "Debes ingresar al menos 2 puntos." << std::endl;
        return -1;
    }

    for (int i = 0; i < numPoints; i++) {
        Point p;
        std::cout << "Ingresa las coordenadas del punto " << i + 1 << " (x y): ";
        std::cin >> p.x >> p.y;
        p.z = 0.0f;  // Mantener z en 0 para graficar en 2D
        userPoints.push_back(p);
    }

    // Inicializar GLFW
    if (!glfwInit()) {
        return -1;
    }

    // Crear ventana
    GLFWwindow* window = glfwCreateWindow(800, 600, "GRAFICO 2D BAKAN", NULL, NULL);
    if (!window) {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);
    glewInit();  // Inicializar GLEW

    glEnable(GL_DEPTH_TEST);  // Habilitar prueba de profundidad
    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);  // Fondo blanco

    // Inicializar GLUT para dibujar texto
    int argc = 1;
    char* argv[1] = {const_cast<char*>("dummy")};
    glutInit(&argc, argv);

    // Ciclo de renderizado
    while (!glfwWindowShouldClose(window)) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // Limpiar el buffer de color y profundidad

        setupViewport(window);  // Configurar la vista

        // Configurar la cámara en 2D en el plano XY
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();

        // Dibujar ejes, puntos del usuario, y = x^2 y y = sin(x) en el plano XY
        drawAxes();
        renderQuadraticCurve();
        renderSineCurve();
        renderUserPoints();

        // Graficar la distancia entre los dos primeros puntos
        if (userPoints.size() >= 2) {
            renderDistanceBetweenPoints(userPoints[0], userPoints[1]);
        }

        glfwSwapBuffers(window);  // Intercambiar buffers
        glfwPollEvents();  // Procesar eventos
    }

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

